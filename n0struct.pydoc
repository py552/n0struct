Help on package n0struct:

NAME
    n0struct

DESCRIPTION
    # -*- coding: utf-8 -*-
    # 0.01 = 2020-07-25 = Initial version
    # 0.02 = 2020-07-26 = Enhancements
    # 0.03 = 2020-08-02 = Huge enhancements
    # 0.04 = 2020-08-05 = Prepared for upload to pypi.org
    # 0.05 = 2020-08-11 = Huge enhancements: unification of .*compare() .toJson(), .toXml(), n0dict(JSON/XML string)
    # 0.06
    # 0.07 = 2020-09-02 = .compare(transform=..) and .direct_compare(transform=..) added
    # 0.08 = 2020-09-05 = refactoring
    # 0.09 = lost
    # 0.10 = rewritten date related functions
    # 0.11 = 2020-09-17 fixed returning time by date_delta(..)
    # 0.12 = 2020-09-24 added function to find keys in n0dict
    # 0.13 = 2020-10-11
    #        n0dict.nvl(..) now supports complicated path like A/B/C
    #        n0dict.__FindElem(..) previously supports modificators [i], [last()], [last()-X], [-X]
    #                              now additionally supports modificators [text()="XYZ"], [text()=="XYZ"], [text()!="XYZ"], /../
    #                              XYZ must be encoded with urlencode
    # 0.14 = 2020-10-17 n0print prints to stderr
    # 0.15 = 2020-10-19 n0pretty(..): fix for json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes
    #                   strip_namespaces() is added
    # 0.16 = 2020-10-20 strip_namespaces() transformed into transform_structure()
    #                   n0dict.compare() is fixed to use compare_only=
    # 0.17 = 2020-10-22 n0print(..): optimization
    # 0.18 = 2020-10-22 workaround fix for Py38: changing (A,) into [A], because of generates NOT tuple, but initial A
    # 0.19 = 2020-10-24 fixed issue with autotests, recursive convertion is added into constructor
    # 0.20 = 2020-10-26 get_composite_keys(transform=..) is added, numeric checking is fixed
    # 0.21 = 2020-11-09 fixed Exception: Why parent is None?
    #                   date_slash_ddmmyyyy() is added
    # 0.22 = 2020-11-09 fixed date_now() -> str 20 characters YYYYMMDDHHMMSSFFFFFF
    # 0.23 = 2020-11-14 fixed n0list.compare()'s issue if more that one the same records are in the list
    #                   *.compare() return ["othernotfound"] -> "self_unique"
    #                   *.compare() return ["selfnotfound"]  -> "other_unique"
    #                   *.compare() return ["notequal"]      -> "not_equal"
    #                   get_composite_keys(..) -> generate_composite_keys(..)
    # 0.24 = 2020-11-20 added is_exist(..), rewritten to_json(..), AddElem(..)'s optimization started
    # 0.25 = 2020-11-20 removed:
    #                       n0dict. __FindElem(..)
    #                       n0dict. __AddElem(..)
    #                       n0dict. AddElem(..)
    #                   rewritten:
    #                       n0dict. __getitem__(..)
    #                       n0dict. __setitem__(..)
    #                   added:
    #                       n0dict. _find(..)
    #                       n0dict. _add(..)
    # 0.26 = 2020-12-15 rewritten n0dict. nvl()
    # 0.27 = 2020-12-16
    #                   added:
    #                       n0dict. _get(..)
    #                   rewritten:
    #                       n0dict. __getitem__(..)
    #                       n0dict. nvl()
    #                       n0dict. _add()
    #                   fixed:
    #                       n0pretty()
    # 0.28 = 2020-12-17
    #                   renamed:
    #                       n0dict. nvl() -> get(..)
    #                   rewritten:
    #                       n0dict. __setitem__(..)
    #                       n0dict. _add()
    # 0.29 = 2020-12-18
    #                   added:
    #                       n0list. any_*()
    # 0.30 = 2020-12-20
    #                   added:
    #                       n0list. __contains__()  # something in n0list()
    #                       n0dict. valid()
    # 0.31 = 2020-12-20
    #                   rewritten:
    #                       n0dict. _find(..)
    #                       split_name_index(..)
    # 0.32 = 2020-12-21
    #                   fixed:
    #                       n0dict. _find(..): if not parent_node: => if parent_node is None:
    #                                          because of parent_node could be '' as allowed value
    # 0.33 = 2020-12-22
    #                   enhanced:
    #                       n0dict. _find(..): parent_node become mandatory argument
    #                       n0dict. _get(..): support leading '?' in xpath
    # 0.34 = 2020-12-24
    #                   enhanced:
    #                       n0list. __init__(..): option recursively:bool = True was added
    #                       n0dict. __init__(..): option recursively:bool = True was added
    # 0.35 = 2020-12-26
    #                   enhanced:
    #                       n0dict. __xml(..): nodes int, float support added
    #                       n0dict. to_xml(..): multi-root support added
    #                   enhanced version of xmltodict0121 was incapsulated till changes will be merged with main branch of xmltodic
    #                   xmltodict0121 enhancement: automaticaly creation n0dict/n0list structure during XML import
    # 0.36 = 2020-12-27
    #                   xmltodict0121 was removed -- using strandard fuctionality of json and xmltodict: just only dict to n0dict will be automatic converted
    #                   during loading xml/json and automatic conversion list into n0list use named parameter recursively=True in the costructor:
    #                   my_n0dict = n0dict(json_txt, recursively=True)
    #                   enhanced:
    #                       n0dict. __init__(..)
    #                       n0list. __init__(..)
    #                       n0dict. __path(..)
    #                       test_n0struct.py
    # 0.37 = 2020-12-28
    #                   fixed:
    #                       n0dict. __xml(..)
    # 0.38 = 2020-12-29
    #                   enhanced:
    #                       n0dict. __init__(..): option force_n0dict == None|!None was added, used ONLY for JSON text convertion
    #                           force_n0dict == False/0/None => create [] (ordinary dict) nodes during JSON text convertion (json.loads)
    #                           force_n0dict == True/1/any => create n0dict() nodes during JSON text convertion (json.loads)
    #                           recursively == True => convert all list/dict nodes created during JSON text convertion (json.loads) into n0list/n0dict
    #
    #                       Performance results of some real code with JSON convertion:
    #                           JSON_struct = n0dict(JSON_txt, recursively=True) => n0dict/n0list:
    #                               36.889860 MB memory is used, 2.566520 seconds are taken for execution
    #                           JSON_struct = n0dict(JSON_txt, recursively=False) => dict/list => JSON_subnode = n0dict(JSON_struct["node/subnode"]):
    #                               36.945560 MB memory is used, 2.546720 seconds are taken for execution
    #                           JSON_struct = n0dict(JSON_txt, force_n0dict=True) => n0dict/list:
    #                               36.995180 MB memory is used, 2.576020 seconds are taken for execution
    #
    #                       Results are VERY strange, but they are true:
    #                           Minimum memory usage: load as list/dict, and after convert all of them into n0list/n0dict inside constructor
    #                           Maximum speed: load as list/dict, and after convert just requiered nodes into n0dict
    #                       *** BEFORE MAKING DECISION MAKE YOUR OWN PERFORMACE TESTING ***
    #
    #                       Same for XML:
    #                           XML_struct = n0dict(XML_txt, recursively=True) => n0dict/n0list:
    #                           XML_struct = n0dict(XML_txt, recursively=False) => n0dict/list
    #                           XML_struct = n0dict(XML_txt, force_n0dict=True) =>
    #                               force_n0dict is ignored -- the same like n0dict(XML_txt, recursively=False) => n0dict/list
    # 0.39 = 2021-01-04
    #                   fixed:
    #                       n0dict. __init__(..): xmltodict.parse(args[0], dict_constuctor = n0dict),
    # 0.40 = 2021-01-08
    #                   enhanced:
    #                       def n0pretty(item, indent_: int = 0, show_type:bool = True):
    #                   added:
    #                       n0dict. first(..)
    #                       n0list. __getitem__(..)
    #                       n0list. _get(..)
    #                       n0list. get(..)
    #                       n0list. first(..)
    # 0.41 = 2021-01-09
    #                   enhanced:
    #                       Added predicate attrib[contains(text(),"TEXT")] or attrib[text()~~"TEXT"] or [attrib~~"TEXT"]
    #                           xml.first('/repository/instanceInfo/instanceInfoProperty/@value[contains(text(),"PRE")]/../@value'))
    #                           xml.first('/repository/instanceInfo/instanceInfoProperty/@value[text()~~"PRE"]/../@value'))
    #                           xml.first('/repository/instanceInfo/instanceInfoProperty/[@value~~"PRE"]/@value'))
    # 0.42 = 2021-01-22
    #                   enhanced:
    #                       n0debug(..)
    #                       mypy optimization
    # 0.43 = 2021-01-28
    #                   enhanced:
    #                       mypy optimization
    #                       compare()["messages"] -> compare()["differences"]
    #                       compare(exclude=) -> compare(exclude_xpaths=)
    #                   added:
    #                       def load_file(file_name: str) -> list:
    #                       def save_file(file_name: str, lines: typing.Any):
    #                       def load_serialized(...):
    # 0.44 = 2021-02-08
    #                   fixed:
    #                       split_name_index(..)
    # 0.45 = 2021-02-27
    #                   enhanced:
    #                       mypy optimization
    #                       def init_logger(..)
    #                   added:
    #                       def timestamp() -> str:
    #                       def date_yymmdd(now: typing.Union[datetime, None] = None, day_delta: int = 0, month_delta: int = 0) -> str:
    #                       class OrderedSet(MutableSet):
    #                       def unpack_references(initial_dict: dict, initial_key: str, recursive: bool = True) -> OrderedSet:
    #                       class Git():
    #                   fixed:
    #                       n0list. _get(..)
    # 0.45 = 2021-03-05
    #                   added:
    #                       n0dict. def update(self, xpath: typing.Union[dict, str], new_value: str = None) -> n0dict:
    #                       n0dict. def delete(self, xpath: str, recursively: bool = False) -> n0dict:
    #                       n0dict. def pop(self, xpath: str, recursively: bool = False) -> typing.Any:
    # 0.46 = 2021-07-21 optimized for debugging
    # 0.47 = 2021-07-21 fix for n0pretty()
    # 0.48 = 2021-07-22
    #                   added:
    #                       def mask_number(not_masked_number: str):
    #                       def unmask_number(masked_number: str):
    #                       def mask_pan(buffer: str):
    # 0.49 = 2021-07-23 fix for n0pretty()

PACKAGE CONTENTS
    test (package)

CLASSES
    builtins.dict(builtins.object)
        n0dict
    builtins.list(builtins.object)
        n0list
    builtins.object
        Git
    collections.abc.MutableSet(collections.abc.Set)
        OrderedSet
    
    class Git(builtins.object)
     |  Git(repo_root_dir: 'str', repository_url: 'str', rsa_key_path: 'str' = '')
     |  
     |  # ******************************************************************************
     |  # ******************************************************************************
     |  # ******************************************************************************
     |  
     |  Methods defined here:
     |  
     |  __init__(self, repo_root_dir: 'str', repository_url: 'str', rsa_key_path: 'str' = '')
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  checkout(self, branch_name: 'str')
     |      # ##############################################################################################
     |  
     |  log(self, git_arguments: 'typing.Union[str, list]')
     |      # ##############################################################################################
     |  
     |  run(self, git_arguments: 'typing.Union[str, list]', show_result=True) -> 'tuple'
     |      # ##############################################################################################
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class OrderedSet(collections.abc.MutableSet)
     |  OrderedSet(iterable=None)
     |  
     |  A mutable set is a finite, iterable container.
     |  
     |  This class provides concrete generic implementations of all
     |  methods except for __contains__, __iter__, __len__,
     |  add(), and discard().
     |  
     |  To override the comparisons (presumably for speed, as the
     |  semantics are fixed), all you have to do is redefine __le__ and
     |  then the other operations will automatically follow suit.
     |  
     |  Method resolution order:
     |      OrderedSet
     |      collections.abc.MutableSet
     |      collections.abc.Set
     |      collections.abc.Collection
     |      collections.abc.Sized
     |      collections.abc.Iterable
     |      collections.abc.Container
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __contains__(self, key)
     |  
     |  __eq__(self, other)
     |      Return self==value.
     |  
     |  __init__(self, iterable=None)
     |      Initialize self.  See help(type(self)) for accurate signature.
     |  
     |  __iter__(self)
     |  
     |  __len__(self)
     |  
     |  __repr__(self)
     |      Return repr(self).
     |  
     |  __reversed__(self)
     |  
     |  add(self, key)
     |      Add an element.
     |  
     |  discard(self, key)
     |      Remove an element.  Do not raise an exception if absent.
     |  
     |  pop(self, last=True)
     |      Return the popped value.  Raise KeyError if empty.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __abstractmethods__ = frozenset()
     |  
     |  __hash__ = None
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from collections.abc.MutableSet:
     |  
     |  __iand__(self, it)
     |  
     |  __ior__(self, it)
     |  
     |  __isub__(self, it)
     |  
     |  __ixor__(self, it)
     |  
     |  clear(self)
     |      This is slow (creates N new iterators!) but effective.
     |  
     |  remove(self, value)
     |      Remove an element. If not a member, raise a KeyError.
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from collections.abc.Set:
     |  
     |  __and__(self, other)
     |  
     |  __ge__(self, other)
     |      Return self>=value.
     |  
     |  __gt__(self, other)
     |      Return self>value.
     |  
     |  __le__(self, other)
     |      Return self<=value.
     |  
     |  __lt__(self, other)
     |      Return self<value.
     |  
     |  __or__(self, other)
     |  
     |  __rand__ = __and__(self, other)
     |  
     |  __ror__ = __or__(self, other)
     |  
     |  __rsub__(self, other)
     |  
     |  __rxor__ = __xor__(self, other)
     |  
     |  __sub__(self, other)
     |  
     |  __xor__(self, other)
     |  
     |  isdisjoint(self, other)
     |      Return True if two sets have a null intersection.
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from collections.abc.Collection:
     |  
     |  __subclasshook__(C) from abc.ABCMeta
     |      Abstract classes can override this to customize issubclass().
     |      
     |      This is invoked early on by abc.ABCMeta.__subclasscheck__().
     |      It should return True, False or NotImplemented.  If it returns
     |      NotImplemented, the normal algorithm is used.  Otherwise, it
     |      overrides the normal algorithm (and the outcome is cached).
    
    class n0dict(builtins.dict)
     |  n0dict(*args, **kw)
     |  
     |  https://github.com/martinblech/xmltodict/issues/252
     |  For Python >= 3.6, dictionary are Sorted by insertion order, so avoid the use of OrderedDict for those python versions.
     |  
     |  Method resolution order:
     |      n0dict
     |      builtins.dict
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __getitem__(self, xpath)
     |      Public function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, exception IndexError will be raised
     |  
     |  __init__(self, *args, **kw)
     |      args == tuple, kw == mapping(dictionary)
     |      
     |      * == convert from tuple into list of arguments
     |      ** == convert from mapping into list of named arguments
     |      
     |      :param args:
     |      :param kw:
     |          recursively = None/False/0 => don't convert subnodes into n0list/n0dict
     |  
     |  __setitem__(self, xpath: 'str', new_value)
     |      Public function:
     |      self[where1/where2/.../whereN] = value
     |          AKA
     |      self[where1][where2]...[whereN] = value
     |      
     |      if xpath will be started with ?, the nothing will be done if new_value is None or empty
     |      if xpath is exist, then the value will be overwritten
     |      if not exist, then the node will be created
     |      
     |      could be used predicates:
     |          [<item>=<value>]
     |          [<item>='<value>']
     |      or indexes
     |          [0]
     |          [1]
     |          [2]
     |          [-1]
     |          [-2]
     |          [-3]
     |      or functions
     |          [last()]
     |          [last()-1]
     |          [last()-2]
     |      or commands for creating (convertion into list) new node
     |          [new()]
     |  
     |  all_not_valid(self, validate)
     |      # **************************************************************************
     |  
     |  all_valid(self, validate)
     |      # **************************************************************************
     |  
     |  any_not_valid(self, validate)
     |      # **************************************************************************
     |  
     |  any_valid(self, validate)
     |      # **************************************************************************
     |  
     |  compare(self, other: 'n0dict', self_name: 'str' = 'self', other_name: 'str' = 'other', prefix: 'str' = '', continuity_check='continuity_check', one_of_list_compare=<function n0list.compare at 0x00000000035604C0>, composite_key: 'tuple' = (), compare_only: 'tuple' = (), exclude_xpaths: 'tuple' = (), transform: 'typing.Tuple[typing.Tuple[str, typing.Callable, typing.Callable]]' = ()) -> 'n0dict'
     |      # **************************************************************************
     |      # * n0dict. compare(..)
     |      # **************************************************************************
     |  
     |  delete(self, xpath: 'str', recursively: 'bool' = False) -> 'n0dict'
     |      # **************************************************************************
     |  
     |  direct_compare(self, other: 'n0dict', self_name: 'str' = 'self', other_name: 'str' = 'other', prefix: 'str' = '', continuity_check='continuity_check', one_of_list_compare=<function n0list.direct_compare at 0x0000000003560430>, composite_key: 'tuple' = (), compare_only: 'tuple' = (), exclude_xpaths: 'tuple' = (), transform: 'tuple' = ()) -> 'n0dict'
     |      # **************************************************************************
     |      # * n0dict. direct_compare(..)
     |      # **************************************************************************
     |  
     |  first(self, xpath: 'str', if_not_found=None)
     |      Public function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, if_not_found will be returned
     |      If self[where1/where2/.../whereN] is list, thet the first element will be returned
     |  
     |  get(self, xpath: 'str', if_not_found=None)
     |      Public function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, if_not_found will be returned
     |  
     |  has_all(self, tupple_of_keys)
     |      # **************************************************************************
     |      # **************************************************************************
     |  
     |  has_any_of(self, tupple_of_keys)
     |      # **************************************************************************
     |      # **************************************************************************
     |  
     |  isEqual(self, xpath, value)
     |      Public function: return empty lists in dict, if self[xpath] == value
     |  
     |  isExist(self, xpath) -> 'n0dict'
     |      Public function: return empty lists in dict, if self[xpath] exists
     |  
     |  isTheSame(self, xpath, other_n0dict, other_xpath=None, transformation=<function n0dict.<lambda> at 0x0000000003562430>)
     |      Public function: return empty lists in dict, if transformation(self[xpath]) == transformation(other_n0dict[other_xpath])
     |  
     |  is_exist(self, xpath: 'str') -> 'bool'
     |      Public function: return True, if self[xpath] exists
     |  
     |  pop(self, xpath: 'str', recursively: 'bool' = False) -> 'typing.Any'
     |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
     |      If key is not found, d is returned if given, otherwise KeyError is raised
     |  
     |  to_json(self, indent: 'int' = 4) -> 'str'
     |      Public function: export self into json result string
     |  
     |  to_xml(self, indent: 'int' = 4, encoding: 'str' = 'utf-8') -> 'str'
     |      Public function: export self into xml result string
     |  
     |  to_xpath(self, mode: 'int' = None) -> 'str'
     |      Public function: collect elements xpath starts from root and print with indents
     |  
     |  update(self, xpath: 'typing.Union[dict, str]', new_value: 'str' = None) -> 'n0dict'
     |      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
     |      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
     |      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
     |      In either case, this is followed by: for k in F:  D[k] = F[k]
     |  
     |  update_extend(self, other)
     |      # **************************************************************************
     |  
     |  valid(self, node_xpath: 'str', validate, expected_result_for_error: 'bool' = False, msg: 'str' = None)
     |      :param node_xpath:
     |          xpath to the node inside self
     |      :param validate:
     |          list/scalar/function = validation
     |      :param expected_result_for_error:
     |          By default expected that if result of validation is True, then self[node_xpath] is not valid (return False)
     |      :param msg:
     |          if None => return result as bool True(validation)/False
     |      :return:
     |      
     |      Examples:
     |          xml.valid('node/subnode', ["",None], True, "ERROR")
     |              If xml['node/subnode'] is equal "" or None (result of comparising is True), then return ERROR, else ""
     |          xml.valid('node/subnode', ["",None], True)
     |              If xml['node/subnode'] is equal "" or None (result of comparising is True), then return False (not valid), else True
     |          xml.valid('node/subnode', "", True)
     |              If xml['node/subnode'] is equal "" (result of comparising is True), then return False (not valid), else True
     |          xml.valid('node/subnode', [1,2], False, "ERROR")
     |              If xml['node/subnode'] is not equal 1 or 2 (result of comparising is False), then return ERROR, else ""
     |          xml.valid('node/subnode', [1,2], False)
     |              If xml['node/subnode'] is not equal 1 or 2 (result of comparising is False), then return False (not valid), else True
     |          xml.valid('node/subnode', [1,2])
     |              If xml['node/subnode'] is not equal 1 or 2 (result of comparising is False), then return False (not valid), else True
     |  
     |  xpath(self, mode: 'int' = None) -> 'list'
     |      Public function: collect elements xpath starts from root
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.dict:
     |  
     |  __contains__(self, key, /)
     |      True if the dictionary has the specified key, else False.
     |  
     |  __delitem__(self, key, /)
     |      Delete self[key].
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __reversed__(self, /)
     |      Return a reverse iterator over the dict keys.
     |  
     |  __sizeof__(...)
     |      D.__sizeof__() -> size of D in memory, in bytes
     |  
     |  clear(...)
     |      D.clear() -> None.  Remove all items from D.
     |  
     |  copy(...)
     |      D.copy() -> a shallow copy of D
     |  
     |  items(...)
     |      D.items() -> a set-like object providing a view on D's items
     |  
     |  keys(...)
     |      D.keys() -> a set-like object providing a view on D's keys
     |  
     |  popitem(self, /)
     |      Remove and return a (key, value) pair as a 2-tuple.
     |      
     |      Pairs are returned in LIFO (last-in, first-out) order.
     |      Raises KeyError if the dict is empty.
     |  
     |  setdefault(self, key, default=None, /)
     |      Insert key with a value of default if key is not in the dictionary.
     |      
     |      Return the value for key if key is in the dictionary, else default.
     |  
     |  values(...)
     |      D.values() -> an object providing a view on D's values
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from builtins.dict:
     |  
     |  fromkeys(iterable, value=None, /) from builtins.type
     |      Create a new dictionary with keys from iterable and values set to value.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.dict:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from builtins.dict:
     |  
     |  __hash__ = None
    
    class n0list(builtins.list)
     |  n0list(*args, **kw)
     |  
     |  Class extended builtins.list(builtins.object) with additional methods:
     |  . direct_compare()  = compare element self[i] with other[i] with the same indexes
     |  . compare()         = compare element self[i] with any other[?] WITHOUT using sorting
     |  
     |  Method resolution order:
     |      n0list
     |      builtins.list
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __contains__(self, other_list)
     |      Return key in self.
     |  
     |  __getitem__(self, xpath)
     |      Public function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, exception IndexError will be raised
     |  
     |  __init__(self, *args, **kw)
     |      args == tuple, kw == mapping(dictionary)
     |      
     |      * == convert from tuple into list of arguments
     |      ** == convert from mapping into list of named arguments
     |      
     |      :param args:
     |      :param kw:
     |          recursively = None/False/0 => don't convert subnodes into n0list/n0dict
     |  
     |  all_in(self, other_list)
     |      # **************************************************************************
     |  
     |  all_not_in(self, other_list)
     |      # **************************************************************************
     |  
     |  any_in(self, other_list)
     |      # **************************************************************************
     |  
     |  any_not_in(self, other_list)
     |      # **************************************************************************
     |  
     |  compare(self, other: 'n0list', self_name: 'str' = 'self', other_name: 'str' = 'other', prefix: 'str' = '', continuity_check: 'str' = 'continuity_check', composite_key: 'tuple' = (), compare_only: 'tuple' = (), exclude_xpaths: 'tuple' = (), transform: 'tuple' = ()) -> 'n0dict'
     |      Recursively compare self[i] with other[?] WITHOUT using order of elements.
     |      If self[i] is n0list/n0dict (and if other[?] is found with the same type),
     |      then goes deeper with n0list. compare(..)/n0dict.direct_compare(..)
     |      
     |      :param other:
     |      :param self_name:
     |      :param other_name:
     |      :param prefix:
     |      :param continuity_check:
     |      :param composite_key:
     |      :param compare_only:
     |      :param exclude_xpaths:
     |      :param transform: ()|None|empty mean nothing to transform, else [[<xpath to elem>,<lambda for transformatio>],..]
     |      :return:
     |              n0dict({
     |                  "differences":  [], # generated for each case of not equality
     |                  "not_equal":    [], # generated if elements with the same xpath and type are not equal
     |                  "self_unique":  [], # generated if elements from self list don't exist in other list
     |                  "other_unique": [], # generated if elements from other list don't exist in self list
     |                  "difftypes":    [], # generated if elements with the same xpath have different types
     |              })
     |              if not returned["differences"]: self and other are totally equal.
     |  
     |  consists_of_all(self, other_list)
     |      # **************************************************************************
     |  
     |  consists_of_any(self, other_list)
     |      # **************************************************************************
     |  
     |  direct_compare(self, other: 'n0list', self_name: 'str' = 'self', other_name: 'str' = 'other', prefix: 'str' = '', continuity_check: 'str' = 'continuity_check', composite_key: 'tuple' = (), compare_only: 'tuple' = (), exclude_xpaths: 'tuple' = (), transform: 'tuple' = ()) -> 'n0dict'
     |      Recursively compare self[i] with other[i]
     |      strictly according to the order of elements.
     |      If self[i] (other[i] must be the same) is n0list/n0dict, then goes deeper
     |      with n0list.direct_compare/n0dict.direct_compare(..)
     |      
     |      :param self: etalon list for compare.
     |      :param other: list to compare with etalon
     |      :param self_name: <default = "self"> dict/list name, used in result["differences"]
     |      :param other_name: <default = "other"> dict/list name, used in result["differences"]
     |      :param prefix: <default = ""> xpath prefix, used for full xpath generation
     |      :param continuity_check: used for checking that below arguments are defined only with names
     |      :param composite_key:  For compatibility with compare(..)
     |      :param compare_only: For compatibility with compare(..)
     |      :param exclude_xpaths: ()|None|empty mean nothing to exclude
     |      :param transform: ()|None|empty mean nothing to transform, else [[<xpath to elem>,<lambda for transformatio>],..]
     |      :return:
     |              n0dict({
     |                  "differences":  [], # generated for each case of not equality
     |                  "not_equal":    [], # generated if elements with the same xpath and type are not equal
     |                  "self_unique":  [], # generated if elements from self list don't exist in other list
     |                  "other_unique": [], # generated if elements from other list don't exist in self list
     |                  "difftypes":    [], # generated if elements with the same xpath have different types
     |              })
     |              if not returned["differences"]: self and other are totally equal.
     |  
     |  first(self, xpath: 'str', if_not_found=None)
     |      Public function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, if_not_found will be returned
     |      If self[where1/where2/.../whereN] is list, thet the first element will be returned
     |  
     |  get(self, xpath: 'typing.Union[str, int]', if_not_found=None)
     |      Public function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, if_not_found will be returned
     |  
     |  not_consists_of_any(self, other_list)
     |      # **************************************************************************
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.list:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __delitem__(self, key, /)
     |      Delete self[key].
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __iadd__(self, value, /)
     |      Implement self+=value.
     |  
     |  __imul__(self, value, /)
     |      Implement self*=value.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __reversed__(self, /)
     |      Return a reverse iterator over the list.
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  __setitem__(self, key, value, /)
     |      Set self[key] to value.
     |  
     |  __sizeof__(self, /)
     |      Return the size of the list in memory, in bytes.
     |  
     |  append(self, object, /)
     |      Append object to the end of the list.
     |  
     |  clear(self, /)
     |      Remove all items from list.
     |  
     |  copy(self, /)
     |      Return a shallow copy of the list.
     |  
     |  count(self, value, /)
     |      Return number of occurrences of value.
     |  
     |  extend(self, iterable, /)
     |      Extend list by appending elements from the iterable.
     |  
     |  index(self, value, start=0, stop=9223372036854775807, /)
     |      Return first index of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  insert(self, index, object, /)
     |      Insert object before index.
     |  
     |  pop(self, index=-1, /)
     |      Remove and return item at index (default last).
     |      
     |      Raises IndexError if list is empty or index is out of range.
     |  
     |  remove(self, value, /)
     |      Remove first occurrence of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  reverse(self, /)
     |      Reverse *IN PLACE*.
     |  
     |  sort(self, /, *, key=None, reverse=False)
     |      Sort the list in ascending order and return None.
     |      
     |      The sort is in-place (i.e. the list itself is modified) and stable (i.e. the
     |      order of two equal elements is maintained).
     |      
     |      If a key function is given, apply it once to each list item and sort them,
     |      ascending or descending, according to their function values.
     |      
     |      The reverse flag can be set to sort in descending order.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.list:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from builtins.list:
     |  
     |  __hash__ = None

FUNCTIONS
    convert_to_native_format(value, key=None, exception=None, transform_depends_of_key=None)
    
    date_ddmmyyyy(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str DD-MM-YYYY
    
    date_delta(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'datetime'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> date
    
    date_iso(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str ISO date format
    
    date_mmyy(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str MMYY
    
    date_now(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str 20 characters YYYYMMDDHHMMSSFFFFFF
    
    date_slash_ddmmyyyy(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str DD/MM/YYYY
    
    date_yymm(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str YYMM
    
    date_yymmdd(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str YYMMDD
    
    date_yyyymmdd(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str YYYY-MM-DD
    
    from_ddmmmyy(date_str: 'str') -> 'typing.Union[date, str, None]'
        :param date_str: DD-MMM-YY # 16-JUL-20
        :return: str -> date
    
    from_ddmmyyyy(date_str: 'str') -> 'typing.Union[date, str, None]'
        :param date_str: DD-MM-YYYY # 16-07-2020
        :return: str -> date
    
    from_yyyymmdd(date_str: 'str') -> 'typing.Union[date, str, None]'
        :param date_str: YYYY-MM-DD # 2020-07-16
        :return: str -> date
    
    generate_composite_keys(input_list: 'n0list', elements_for_composite_key: 'tuple', prefix: 'str' = None, transform: 'typing.List[typing.Tuple[str, typing.Callable[[str], str]]]' = []) -> 'list'
        serialization all or {elements_for_composite_key} elements of {input_list[]}
        :param transform: ()|None|empty mean nothing to transform, else [[<xpath to elem>,<lambda for transformatio>],..]
        :return:
            [[<composite_key>,[<index of entry>],...}
    
    get__flag_compare_check_different_types() -> 'bool'
    
    get__flag_compare_return_difference_of_values() -> 'bool'
    
    get_key_by_value(dict_: 'dict', value_: 'typing.Any')
        :param dict_:
        :param value_:
        :return: last key which is associated with value_ in dict_
    
    init_logger(debug_level: 'str' = 'TRACE', debug_output=<_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>, debug_timeformat: 'str' = 'YYYY-MM-DD HH:mm:ss.SSS', debug_showobjectid=True, debug_logtofile=True, log_file_name: 'str' = None)
    
    join_triplets(in_list: 'typing.Union[None, str, tuple, list]', level=0) -> 'str'
        join_triplets(in_list: typing.Union[None, str, tuple, list], level = 0) -> str:
        
        join elements with middle sepataror:
            [elem1, separator, elem2]   => elem1, separator, elem2
            [elem1, separator, None]    => elem1
            [None, separator, elem2]    => elem2
    
    load_file(file_name: 'str') -> 'list'
        # ********************************************************************
        # ********************************************************************
    
    load_serialized(file_name: 'str', equal_tag: 'str' = '=', separator_tag: 'str' = ';', comment_tags: 'typing.Union[tuple, list]' = ('#', '//'), remove_startswith: 'str' = '', remove_endswith: 'str' = '') -> 'n0list'
        # ********************************************************************
    
    mask_number(not_masked_number: 'str')
        Public function: convert numbers into similar looks letters
    
    mask_pan(buffer: 'str')
        Public function: mask PANs in buffer
    
    n0debug(var_name: 'str', level: 'str' = 'DEBUG')
        Print value of the variable with name {var_name},
        depends of value in global variable {__debug_level}.
        
        :param var_name:
        :param level:
        :return:
    
    n0debug_calc(var_object, var_name: 'str' = '', level: 'str' = 'DEBUG', internal_call: 'int' = 0)
        Print  calculated value (for example returned by function),
        depends of value in global variable __debug_level.
        
        :param var_object:
        :param var_name:
        :param level:
        :return:
    
    n0debug_object(object_name: 'str', level: 'str' = 'DEBUG')
        # ********************************************************************
    
    n0eval(_str: 'str') -> 'typing.Union[int, float, typing.Any]'
        # ********************************************************************
        # ********************************************************************
    
    n0isnumeric(value: 'str') -> 'bool'
        # ********************************************************************
        # ********************************************************************
    
    n0pretty(item: 'typing.Any', indent_: 'int' = 0, show_type: 'bool' = None, __indent_size: 'int' = 4, __quotes: 'str' = '"')
        :param item:
        :param indent_:
        :return:
    
    n0print(text: 'str', level: 'str' = 'INFO', internal_call: 'int' = 0)
        if {level} <= {__debug_level} then print {text}{end}
        
        :param text:
        :param level:
        :param end:
        :param internal_call:
        :return: None
    
    notemptyitems(item)
        # ******************************************************************************
        # notemptyitems(item):
        #   Check item or recursively subitems of item.
        #   Return count of notempty item/subitems.
        # ******************************************************************************
    
    random_from(from_list: 'list') -> 'typing.Any'
        :param from_list:
        :return: from_list[rnd]
    
    rnd(till_not_included: 'int') -> 'int'
        :param till_not_included:
        :return: int [0..till_not_included)
    
    save_file(file_name: 'str', lines: 'typing.Any')
        # ********************************************************************
    
    set__flag_compare_check_different_types(value: 'bool')
        if __flag_compare_check_different_types == True, then
        validate type of attributes in .compare()/.direct_compare()
        and return result["difftypes"]
    
    set__flag_compare_return_difference_of_values(value: 'bool')
        if __flag_compare_return_difference_of_values == True, then
        if values of attributes are different and are int,float,
        return additional element in result["not_equal"] with difference
    
    split_name_index(node_name: 'str') -> 'typing.Tuple[str, typing.Union[str, typing.Tuple[str, str, typing.Union[str, bool]]]]'
        # ********************************************************************
        # ********************************************************************
    
    split_pair(in_str: 'str', separator: 'str', transform1: 'callable' = <function <lambda> at 0x0000000003565430>, transform2: 'callable' = <function <lambda> at 0x0000000003565700>, default_element: 'int' = 1) -> 'tuple'
        split_pair(in_str: str, separator: str, transform1: callable = lambda x:x, transform2: callable = lambda x:x, default_element: int = 1) -> tuple:
        
        split string into 2 sub strings in any cases:
            '' by '://'                                     => (None,   None)
            'www.aaa.com' by '://'                          => (None,   'www.aaa.com')
            'https://www.aaa.com' by '://'                  => ('http', 'www.aaa.com')
            'www.aaa.com',default_element = 0 by '/'        => ('www.aaa.com')
            'www.aaa.com/path',default_element = 0 by '/'   => ('www.aaa.com', 'path')
    
    strip_ns lambda key
        # ******************************************************************************
    
    timestamp() -> 'str'
        :return: now -> str 13 characters YYMMDD_HHMMSS
    
    to_date(date_str: 'str') -> 'typing.Union[date, str]'
        # ********************************************************************
    
    transform_structure(in_structure, transform_key=<function <lambda> at 0x000000000355ECA0>, transform_value=<function convert_to_native_format at 0x000000000355ED30>)
        # ******************************************************************************
    
    unmask_number(masked_number: 'str')
        Public function: convert letters into similar looks numbers
    
    unpack_references(initial_dict: 'dict', initial_key: 'str', recursive: 'bool' = True) -> 'OrderedSet'
        # ******************************************************************************
        # 2 levels dict:
        # initial_dict:
        #   key1:
        #       - item1
        #       - item2
        #   key2:
        #       - key1
        #       - item3
        #       - item4
        # Unpack references recursive: bool = True
        # unpacked_dict = {key : list(unpack_references(initial_dict, key)) for key in initial_dict}
        # unpacked_dict:
        #   key1:
        #       - item1
        #       - item2
        #   key2:
        #       - item1
        #       - item2
        #       - item3
        #       - item4
        # Remove references recursive: bool = False
        # unpacked_dict = {key : list(unpack_references(initial_dict, key), False) for key in initial_dict}
        # unpacked_dict:
        #   key1:
        #       - item1
        #       - item2
        #   key2:
        #       - item3
        #       - item4
    
    xpath_match(xpath: 'str', xpath_list: 'typing.Union[str, list, tuple]') -> 'int'
        :param xpath:
            xpath: str
        :param xpath_list:
            xpath_list: str or list|tuple
        :return:
             0 not matched any of xpath_list
            >0 matched

DATA
    annotations = _Feature((3, 7, 0, 'beta', 1), (3, 10, 0, 'alpha', 0), 1...
    compiled_regexp_mask_pan = re.compile('(([^0-9]|^)?(000)?[456][0-9]{5}...
    logger = <loguru.logger handlers=[(id=0, level=10, sink=<stderr>)]>

FILE
    d:\repo\n0struct\n0struct\__init__.py


