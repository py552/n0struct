Help on package n0struct:

NAME
    n0struct

DESCRIPTION
    # 0.01 = 2020-07-25 = Initial version
    # 0.02 = 2020-07-26 = Enhancements
    # 0.03 = 2020-08-02 = Huge enhancements
    # 0.04 = 2020-08-05 = Prepared for upload to pypi.org
    # 0.05 = 2020-08-11 = Huge enhancements: unification of .*compare() .toJson(), .toXml(), n0dict(JSON/XML string)
    # 0.06
    # 0.07 = 2020-09-02 = .compare(transform=..) and .direct_compare(transform=..) added
    # 0.08 = 2020-09-05 = refactoring
    # 0.09 = lost
    # 0.10 = rewritten date related functions
    # 0.11 = 2020-09-17 fixed returning time by date_delta(..)
    # 0.12 = 2020-09-24 added function to find keys in n0dict
    # 0.13 = 2020-10-11
    #        n0dict.nvl(..) now supports complicated path like A/B/C
    #        n0dict.__FindElem(..) previously supports modificators [i], [last()], [last()-X], [-X]
    #                              now additionally supports modificators [text()="XYZ"], [text()=="XYZ"], [text()!="XYZ"], /../
    #                              XYZ must be encoded with urlencode
    # 0.14 = 2020-10-17 n0print prints to stderr
    # 0.15 = 2020-10-19 n0pretty(..): fix for json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes
    #                   strip_namespaces() is added
    # 0.16 = 2020-10-20 strip_namespaces() transformed into transform_structure()
    #                   n0dict.compare() is fixed to use compare_only=
    # 0.17 = 2020-10-22 n0print(..): optimization
    # 0.18 = 2020-10-22 workaround fix for Py38: changing (A,) into [A], because of generates NOT tuple, but initial A
    # 0.19 = 2020-10-24 fixed issue with autotests, recursive convertion is added into constructor
    # 0.20 = 2020-10-26 get_composite_keys(transform=..) is added, numeric checking is fixed
    # 0.21 = 2020-11-09 fixed Exception: Why parent is None?
    #                   date_slash_ddmmyyyy() is added
    # 0.22 = 2020-11-09 fixed date_now() -> str 20 characters YYYYMMDDHHMMSSFFFFFF
    # 0.23 = 2020-11-14 fixed n0list.compare()'s issue if more that one the same records are in the list
    #                   *.compare() return ["othernotfound"] -> "self_unique"
    #                   *.compare() return ["selfnotfound"]  -> "other_unique"
    #                   *.compare() return ["notequal"]      -> "not_equal"
    #                   get_composite_keys(..) -> generate_composite_keys(..)
    # 0.24 = 2020-11-20 added is_exist(..), rewritten to_json(..), AddElem(..)'s optimization started
    # 0.25 = 2020-11-20 removed:
    #                       n0dict. __FindElem(..)
    #                       n0dict. __AddElem(..)
    #                       n0dict. AddElem(..)
    #                   rewritten:
    #                       n0dict. __getitem__(..)
    #                       n0dict. __setitem__(..)
    #                   added:
    #                       n0dict. _find(..)
    #                       n0dict. _add(..)
    # 0.26 = 2020-12-15 rewritten n0dict. nvl()
    # 0.27 = 2020-12-16
    #                   added:
    #                       n0dict. _get(..)
    #                   rewritten:
    #                       n0dict. __getitem__(..)
    #                       n0dict. nvl()
    #                       n0dict. _add()
    #                   fixed:
    #                       n0pretty()
    # 0.28 = 2020-12-17
    #                   renamed:
    #                       n0dict. nvl() -> get(..)
    #                   rewritten:
    #                       n0dict. __setitem__(..)
    #                       n0dict. _add()
    # 0.29 = 2020-12-18
    #                   added:
    #                       n0list. any_*()
    # 0.30 = 2020-12-20
    #                   added:
    #                       n0list. __contains__()  # something in n0list()
    #                       n0dict. valid()
    # 0.31 = 2020-12-20
    #                   rewritten:
    #                       n0dict. _find(..)
    #                       split_name_index(..)
    # 0.32 = 2020-12-21
    #                   fixed:
    #                       n0dict. _find(..): if not parent_node: => if parent_node is None:
    #                                          because of parent_node could be '' as allowed value
    # 0.33 = 2020-12-22
    #                   enhanced:
    #                       n0dict. _find(..): parent_node become mandatory argument
    #                       n0dict. _get(..): support leading '?' in xpath
    # 0.34 = 2020-12-24
    #                   enhanced:
    #                       n0list. __init__(..): option recursively:bool = True was added
    #                       n0dict. __init__(..): option recursively:bool = True was added
    # 0.35 = 2020-12-26
    #                   enhanced:
    #                       n0dict. __xml(..): nodes int, float support added
    #                       n0dict. to_xml(..): multi-root support added
    #                   enhanced version of xmltodict0121 was incapsulated till changes will be merged with main branch of xmltodic
    #                   xmltodict0121 enhancement: automaticaly creation n0dict/n0list structure during XML import
    # 0.36 = 2020-12-27
    #                   xmltodict0121 was removed -- using strandard fuctionality of json and xmltodict: just only dict to n0dict will be automatic converted
    #                   during loading xml/json and automatic conversion list into n0list use named parameter recursively=True in the costructor:
    #                   my_n0dict = n0dict(json_txt, recursively=True)
    #                   enhanced:
    #                       n0dict. __init__(..)
    #                       n0list. __init__(..)
    #                       n0dict. __path(..)
    #                       test_n0struct.py
    # 0.37 = 2020-12-28
    #                   fixed:
    #                       n0dict. __xml(..)
    # 0.38 = 2020-12-29
    #                   enhanced:
    #                       n0dict. __init__(..): option force_n0dict == None|!None was added, used ONLY for JSON text convertion
    #                           force_n0dict == False/0/None => create [] (ordinary dict) nodes during JSON text convertion (json.loads)
    #                           force_n0dict == True/1/any => create n0dict() nodes during JSON text convertion (json.loads)
    #                           recursively == True => convert all list/dict nodes created during JSON text convertion (json.loads) into n0list/n0dict
    #
    #                       Performance results of some real code with JSON convertion:
    #                           JSON_struct = n0dict(JSON_txt, recursively=True) => n0dict/n0list:
    #                               36.889860 MB memory is used, 2.566520 seconds are taken for execution
    #                           JSON_struct = n0dict(JSON_txt, recursively=False) => dict/list => JSON_subnode = n0dict(JSON_struct["node/subnode"]):
    #                               36.945560 MB memory is used, 2.546720 seconds are taken for execution
    #                           JSON_struct = n0dict(JSON_txt, force_n0dict=True) => n0dict/list:
    #                               36.995180 MB memory is used, 2.576020 seconds are taken for execution
    #
    #                       Results are VERY strange, but they are true:
    #                           Minimum memory usage: load as list/dict, and after convert all of them into n0list/n0dict inside constructor
    #                           Maximum speed: load as list/dict, and after convert just requiered nodes into n0dict
    #                       *** BEFORE MAKING DECISION MAKE YOUR OWN PERFORMACE TESTING ***
    #
    #                       Same for XML:
    #                           XML_struct = n0dict(XML_txt, recursively=True) => n0dict/n0list:
    #                           XML_struct = n0dict(XML_txt, recursively=False) => n0dict/list
    #                           XML_struct = n0dict(XML_txt, force_n0dict=True) =>
    #                               force_n0dict is ignored -- the same like n0dict(XML_txt, recursively=False) => n0dict/list
    # 0.39 = 2021-01-04
    #                   fixed:
    #                       n0dict. __init__(..): xmltodict.parse(args[0], dict_constuctor = n0dict),
    # 0.40 = 2021-01-08
    #                   enhanced:
    #                       def n0pretty(item, indent_: int = 0, show_type:bool = True):
    #                   added:
    #                       n0dict. first(..)
    #                       n0list. __getitem__(..)
    #                       n0list. _get(..)
    #                       n0list. get(..)
    #                       n0list. first(..)
    # 0.41 = 2021-01-09
    #                   enhanced:
    #                       Added predicate attrib[contains(text(),"TEXT")] or attrib[text()~~"TEXT"] or [attrib~~"TEXT"]
    #                           xml.first('/repository/instanceInfo/instanceInfoProperty/@value[contains(text(),"PRE")]/../@value'))
    #                           xml.first('/repository/instanceInfo/instanceInfoProperty/@value[text()~~"PRE"]/../@value'))
    #                           xml.first('/repository/instanceInfo/instanceInfoProperty/[@value~~"PRE"]/@value'))
    # 0.42 = 2021-01-22
    #                   enhanced:
    #                       n0debug(..)
    #                       mypy optimization
    # 0.43 = 2021-01-28
    #                   enhanced:
    #                       mypy optimization
    #                       compare()["messages"] -> compare()["differences"]
    #                       compare(exclude=) -> compare(exclude_xpaths=)
    #                   added:
    #                       def load_file(file_name: str) -> list:
    #                       def save_file(file_name: str, lines: typing.Any):
    #                       def load_serialized(...):

PACKAGE CONTENTS
    test (package)

CLASSES
    builtins.dict(builtins.object)
        n0dict
    builtins.list(builtins.object)
        n0list
    
    class n0dict(builtins.dict)
     |  n0dict(*args, **kw)
     |  
     |  https://github.com/martinblech/xmltodict/issues/252
     |  For Python >= 3.6, dictionary are Sorted by insertion order, so avoid the use of OrderedDict for those python versions.
     |  
     |  Method resolution order:
     |      n0dict
     |      builtins.dict
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __getitem__(self, xpath)
     |      Private function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, exception IndexError will be raised
     |  
     |  __init__(self, *args, **kw)
     |      args == tuple, kw == mapping(dictionary)
     |      
     |      * == convert from tuple into list of arguments
     |      ** == convert from mapping into list of named arguments
     |      
     |      :param args:
     |      :param kw:
     |          recursively = None/False/0 => don't convert subnodes into n0list/n0dict
     |  
     |  __setitem__(self, xpath: 'str', new_value)
     |      Private function:
     |      self[where1/where2/.../whereN] = value
     |          AKA
     |      self[where1][where2]...[whereN] = value
     |      
     |      if xpath will be started with ?, the nothing will be done if new_value is None or empty
     |      if xpath is exist, then the value will be overwritten
     |      if not exist, then the node will be created
     |      
     |      could be used predicates:
     |          [<item>=<value>]
     |          [<item>='<value>']
     |      or indexes
     |          [0]
     |          [1]
     |          [2]
     |          [-1]
     |          [-2]
     |          [-3]
     |      or functions
     |          [last()]
     |          [last()-1]
     |          [last()-2]
     |      or commands for creating (convertion into list) new node
     |          [new()]
     |  
     |  all_not_valid(self, validate)
     |      # ******************************************************************************
     |  
     |  all_valid(self, validate)
     |      # ******************************************************************************
     |  
     |  any_not_valid(self, validate)
     |      # ******************************************************************************
     |  
     |  any_valid(self, validate)
     |      # ******************************************************************************
     |  
     |  compare(self, other: 'n0dict', self_name: 'str' = 'self', other_name: 'str' = 'other', prefix: 'str' = '', continuity_check='continuity_check', one_of_list_compare=<function n0list.compare at 0x00000280E7C97DC0>, composite_key: 'tuple' = (), compare_only: 'tuple' = (), exclude_xpaths: 'tuple' = (), transform: 'typing.Tuple[typing.Tuple[str, typing.Callable, typing.Callable]]' = ()) -> 'n0dict'
     |      # ******************************************************************************
     |      # * n0dict. compare(..)
     |      # ******************************************************************************
     |  
     |  direct_compare(self, other: 'n0dict', self_name: 'str' = 'self', other_name: 'str' = 'other', prefix: 'str' = '', continuity_check='continuity_check', one_of_list_compare=<function n0list.direct_compare at 0x00000280E7C97D30>, composite_key: 'tuple' = (), compare_only: 'tuple' = (), exclude_xpaths: 'tuple' = (), transform: 'tuple' = ()) -> 'n0dict'
     |      # ******************************************************************************
     |      # * n0dict. direct_compare(..)
     |      # ******************************************************************************
     |  
     |  first(self, xpath: 'str', if_not_found=None)
     |      Private function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, if_not_found will be returned
     |      If self[where1/where2/.../whereN] is list, thet the first element will be returned
     |  
     |  get(self, xpath: 'str', if_not_found=None)
     |      Private function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, if_not_found will be returned
     |  
     |  has_all(self, tupple_of_keys)
     |      # ******************************************************************************
     |      # ******************************************************************************
     |  
     |  has_any_of(self, tupple_of_keys)
     |      # ******************************************************************************
     |      # ******************************************************************************
     |  
     |  isEqual(self, xpath, value)
     |      Public function: return empty lists in dict, if self[xpath] == value
     |  
     |  isExist(self, xpath) -> 'n0dict'
     |      Public function: return empty lists in dict, if self[xpath] exists
     |  
     |  isTheSame(self, xpath, other_n0dict, other_xpath=None, transformation=<function n0dict.<lambda> at 0x00000280E7C9AD30>)
     |      Public function: return empty lists in dict, if transformation(self[xpath]) == transformation(other_n0dict[other_xpath])
     |  
     |  is_exist(self, xpath: 'str') -> 'bool'
     |      Public function: return True, if self[xpath] exists
     |  
     |  to_json(self, indent: 'int' = 4) -> 'str'
     |      Public function: export self into json result string
     |  
     |  to_xml(self, indent: 'int' = 4, encoding: 'str' = 'utf-8') -> 'str'
     |      Public function: export self into xml result string
     |  
     |  to_xpath(self, mode: 'int' = None) -> 'str'
     |      Public function: collect elements xpath starts from root and print with indents
     |  
     |  update_extend(self, other)
     |      # ******************************************************************************
     |  
     |  valid(self, node_xpath: 'str', validate, expected_result_for_error: 'bool' = False, msg: 'str' = None)
     |      :param node_xpath:
     |          xpath to the node inside self
     |      :param validate:
     |          list/scalar/function = validation
     |      :param expected_result_for_error:
     |          By default expected that if result of validation is True, then self[node_xpath] is not valid (return False)
     |      :param msg:
     |          if None => return result as bool True(validation)/False
     |      :return:
     |      
     |      Examples:
     |          xml.valid('node/subnode', ["",None], True, "ERROR")
     |              If xml['node/subnode'] is equal "" or None (result of comparising is True), then return ERROR, else ""
     |          xml.valid('node/subnode', ["",None], True)
     |              If xml['node/subnode'] is equal "" or None (result of comparising is True), then return False (not valid), else True
     |          xml.valid('node/subnode', "", True)
     |              If xml['node/subnode'] is equal "" (result of comparising is True), then return False (not valid), else True
     |          xml.valid('node/subnode', [1,2], False, "ERROR")
     |              If xml['node/subnode'] is not equal 1 or 2 (result of comparising is False), then return ERROR, else ""
     |          xml.valid('node/subnode', [1,2], False)
     |              If xml['node/subnode'] is not equal 1 or 2 (result of comparising is False), then return False (not valid), else True
     |          xml.valid('node/subnode', [1,2])
     |              If xml['node/subnode'] is not equal 1 or 2 (result of comparising is False), then return False (not valid), else True
     |  
     |  xpath(self, mode: 'int' = None) -> 'list'
     |      Public function: collect elements xpath starts from root
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.dict:
     |  
     |  __contains__(self, key, /)
     |      True if the dictionary has the specified key, else False.
     |  
     |  __delitem__(self, key, /)
     |      Delete self[key].
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __reversed__(self, /)
     |      Return a reverse iterator over the dict keys.
     |  
     |  __sizeof__(...)
     |      D.__sizeof__() -> size of D in memory, in bytes
     |  
     |  clear(...)
     |      D.clear() -> None.  Remove all items from D.
     |  
     |  copy(...)
     |      D.copy() -> a shallow copy of D
     |  
     |  items(...)
     |      D.items() -> a set-like object providing a view on D's items
     |  
     |  keys(...)
     |      D.keys() -> a set-like object providing a view on D's keys
     |  
     |  pop(...)
     |      D.pop(k[,d]) -> v, remove specified key and return the corresponding value.
     |      If key is not found, d is returned if given, otherwise KeyError is raised
     |  
     |  popitem(self, /)
     |      Remove and return a (key, value) pair as a 2-tuple.
     |      
     |      Pairs are returned in LIFO (last-in, first-out) order.
     |      Raises KeyError if the dict is empty.
     |  
     |  setdefault(self, key, default=None, /)
     |      Insert key with a value of default if key is not in the dictionary.
     |      
     |      Return the value for key if key is in the dictionary, else default.
     |  
     |  update(...)
     |      D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.
     |      If E is present and has a .keys() method, then does:  for k in E: D[k] = E[k]
     |      If E is present and lacks a .keys() method, then does:  for k, v in E: D[k] = v
     |      In either case, this is followed by: for k in F:  D[k] = F[k]
     |  
     |  values(...)
     |      D.values() -> an object providing a view on D's values
     |  
     |  ----------------------------------------------------------------------
     |  Class methods inherited from builtins.dict:
     |  
     |  fromkeys(iterable, value=None, /) from builtins.type
     |      Create a new dictionary with keys from iterable and values set to value.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.dict:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from builtins.dict:
     |  
     |  __hash__ = None
    
    class n0list(builtins.list)
     |  n0list(*args, **kw)
     |  
     |  Class extended builtins.list(builtins.object) with additional methods:
     |  . direct_compare()  = compare element self[i] with other[i] with the same indexes
     |  . compare()         = compare element self[i] with any other[?] WITHOUT using sorting
     |  
     |  Method resolution order:
     |      n0list
     |      builtins.list
     |      builtins.object
     |  
     |  Methods defined here:
     |  
     |  __contains__(self, other_list)
     |      Return key in self.
     |  
     |  __getitem__(self, xpath)
     |      Private function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, exception IndexError will be raised
     |  
     |  __init__(self, *args, **kw)
     |      args == tuple, kw == mapping(dictionary)
     |      
     |      * == convert from tuple into list of arguments
     |      ** == convert from mapping into list of named arguments
     |      
     |      :param args:
     |      :param kw:
     |          recursively = None/False/0 => don't convert subnodes into n0list/n0dict
     |  
     |  all_in(self, other_list)
     |      # ******************************************************************************
     |  
     |  all_not_in(self, other_list)
     |      # ******************************************************************************
     |  
     |  any_in(self, other_list)
     |      # ******************************************************************************
     |  
     |  any_not_in(self, other_list)
     |      # ******************************************************************************
     |  
     |  compare(self, other: 'n0list', self_name: 'str' = 'self', other_name: 'str' = 'other', prefix: 'str' = '', continuity_check: 'str' = 'continuity_check', composite_key: 'tuple' = (), compare_only: 'tuple' = (), exclude_xpaths: 'tuple' = (), transform: 'tuple' = ()) -> 'n0dict'
     |      Recursively compare self[i] with other[?] WITHOUT using order of elements.
     |      If self[i] is n0list/n0dict (and if other[?] is found with the same type),
     |      then goes deeper with n0list. compare(..)/n0dict.direct_compare(..)
     |      
     |      :param other:
     |      :param self_name:
     |      :param other_name:
     |      :param prefix:
     |      :param continuity_check:
     |      :param composite_key:
     |      :param compare_only:
     |      :param exclude_xpaths:
     |      :param transform: ()|None|empty mean nothing to transform, else [[<xpath to elem>,<lambda for transformatio>],..]
     |      :return:
     |              n0dict({
     |                  "differences":  [], # generated for each case of not equality
     |                  "not_equal":    [], # generated if elements with the same xpath and type are not equal
     |                  "self_unique":  [], # generated if elements from self list don't exist in other list
     |                  "other_unique": [], # generated if elements from other list don't exist in self list
     |                  "difftypes":    [], # generated if elements with the same xpath have different types
     |              })
     |              if not returned["differences"]: self and other are totally equal.
     |  
     |  consists_of_all(self, other_list)
     |      # ******************************************************************************
     |  
     |  consists_of_any(self, other_list)
     |      # ******************************************************************************
     |  
     |  direct_compare(self, other: 'n0list', self_name: 'str' = 'self', other_name: 'str' = 'other', prefix: 'str' = '', continuity_check: 'str' = 'continuity_check', composite_key: 'tuple' = (), compare_only: 'tuple' = (), exclude_xpaths: 'tuple' = (), transform: 'tuple' = ()) -> 'n0dict'
     |      Recursively compare self[i] with other[i]
     |      strictly according to the order of elements.
     |      If self[i] (other[i] must be the same) is n0list/n0dict, then goes deeper
     |      with n0list.direct_compare/n0dict.direct_compare(..)
     |      
     |      :param self: etalon list for compare.
     |      :param other: list to compare with etalon
     |      :param self_name: <default = "self"> dict/list name, used in result["differences"]
     |      :param other_name: <default = "other"> dict/list name, used in result["differences"]
     |      :param prefix: <default = ""> xpath prefix, used for full xpath generation
     |      :param continuity_check: used for checking that below arguments are defined only with names
     |      :param composite_key:  For compatibility with compare(..)
     |      :param compare_only: For compatibility with compare(..)
     |      :param exclude_xpaths: ()|None|empty mean nothing to exclude
     |      :param transform: ()|None|empty mean nothing to transform, else [[<xpath to elem>,<lambda for transformatio>],..]
     |      :return:
     |              n0dict({
     |                  "differences":  [], # generated for each case of not equality
     |                  "not_equal":    [], # generated if elements with the same xpath and type are not equal
     |                  "self_unique":  [], # generated if elements from self list don't exist in other list
     |                  "other_unique": [], # generated if elements from other list don't exist in self list
     |                  "difftypes":    [], # generated if elements with the same xpath have different types
     |              })
     |              if not returned["differences"]: self and other are totally equal.
     |  
     |  first(self, xpath: 'str', if_not_found=None)
     |      Public function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, if_not_found will be returned
     |      If self[where1/where2/.../whereN] is list, thet the first element will be returned
     |  
     |  get(self, xpath: 'str', if_not_found=None)
     |      Public function:
     |      return self[where1/where2/.../whereN]
     |          AKA
     |      return self[where1][where2]...[whereN]
     |      
     |      If any of [where1][where2]...[whereN] are not found, if_not_found will be returned
     |  
     |  not_consists_of_any(self, other_list)
     |      # ******************************************************************************
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from builtins.list:
     |  
     |  __add__(self, value, /)
     |      Return self+value.
     |  
     |  __delitem__(self, key, /)
     |      Delete self[key].
     |  
     |  __eq__(self, value, /)
     |      Return self==value.
     |  
     |  __ge__(self, value, /)
     |      Return self>=value.
     |  
     |  __getattribute__(self, name, /)
     |      Return getattr(self, name).
     |  
     |  __gt__(self, value, /)
     |      Return self>value.
     |  
     |  __iadd__(self, value, /)
     |      Implement self+=value.
     |  
     |  __imul__(self, value, /)
     |      Implement self*=value.
     |  
     |  __iter__(self, /)
     |      Implement iter(self).
     |  
     |  __le__(self, value, /)
     |      Return self<=value.
     |  
     |  __len__(self, /)
     |      Return len(self).
     |  
     |  __lt__(self, value, /)
     |      Return self<value.
     |  
     |  __mul__(self, value, /)
     |      Return self*value.
     |  
     |  __ne__(self, value, /)
     |      Return self!=value.
     |  
     |  __repr__(self, /)
     |      Return repr(self).
     |  
     |  __reversed__(self, /)
     |      Return a reverse iterator over the list.
     |  
     |  __rmul__(self, value, /)
     |      Return value*self.
     |  
     |  __setitem__(self, key, value, /)
     |      Set self[key] to value.
     |  
     |  __sizeof__(self, /)
     |      Return the size of the list in memory, in bytes.
     |  
     |  append(self, object, /)
     |      Append object to the end of the list.
     |  
     |  clear(self, /)
     |      Remove all items from list.
     |  
     |  copy(self, /)
     |      Return a shallow copy of the list.
     |  
     |  count(self, value, /)
     |      Return number of occurrences of value.
     |  
     |  extend(self, iterable, /)
     |      Extend list by appending elements from the iterable.
     |  
     |  index(self, value, start=0, stop=9223372036854775807, /)
     |      Return first index of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  insert(self, index, object, /)
     |      Insert object before index.
     |  
     |  pop(self, index=-1, /)
     |      Remove and return item at index (default last).
     |      
     |      Raises IndexError if list is empty or index is out of range.
     |  
     |  remove(self, value, /)
     |      Remove first occurrence of value.
     |      
     |      Raises ValueError if the value is not present.
     |  
     |  reverse(self, /)
     |      Reverse *IN PLACE*.
     |  
     |  sort(self, /, *, key=None, reverse=False)
     |      Sort the list in ascending order and return None.
     |      
     |      The sort is in-place (i.e. the list itself is modified) and stable (i.e. the
     |      order of two equal elements is maintained).
     |      
     |      If a key function is given, apply it once to each list item and sort them,
     |      ascending or descending, according to their function values.
     |      
     |      The reverse flag can be set to sort in descending order.
     |  
     |  ----------------------------------------------------------------------
     |  Static methods inherited from builtins.list:
     |  
     |  __new__(*args, **kwargs) from builtins.type
     |      Create and return a new object.  See help(type) for accurate signature.
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from builtins.list:
     |  
     |  __hash__ = None

FUNCTIONS
    convert_to_native_format(value, key=None, exception=None, transform_depends_of_key=None)
        # }
        # def convert_to_native_format(value, key = None, exception = None, transform_depends_of_key = keys_for_currency_convertion):
    
    date_ddmmyyyy(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str DD-MM-YYYY
    
    date_delta(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'datetime'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> date
    
    date_iso(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str ISO date format
    
    date_mmyy(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str MMYY
    
    date_now(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str 20 characters YYYYMMDDHHMMSSFFFFFF
    
    date_slash_ddmmyyyy(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str DD/MM/YYYY
    
    date_yymm(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str YYMM
    
    date_yyyymmdd(now: 'typing.Union[datetime, None]' = None, day_delta: 'int' = 0, month_delta: 'int' = 0) -> 'str'
        :param day_delta:
        :param month_delta:
        :return: today + day_delta + month_delta -> str YYYY-MM-DD
    
    from_ddmmmyy(date_str: 'str') -> 'typing.Union[date, str, None]'
        :param date_str: DD-MMM-YY # 16-JUL-20
        :return: str -> date
    
    from_ddmmyyyy(date_str: 'str') -> 'typing.Union[date, str, None]'
        :param date_str: DD-MM-YYYY # 16-07-2020
        :return: str -> date
    
    from_yyyymmdd(date_str: 'str') -> 'typing.Union[date, str, None]'
        :param date_str: YYYY-MM-DD # 2020-07-16
        :return: str -> date
    
    generate_composite_keys(input_list: 'n0list', elements_for_composite_key: 'tuple', prefix: 'str' = None, transform: 'typing.List[typing.Tuple[str, typing.Callable[[str], str]]]' = []) -> 'list'
        serialization all or {elements_for_composite_key} elements of {input_list[]}
        :param transform: ()|None|empty mean nothing to transform, else [[<xpath to elem>,<lambda for transformatio>],..]
        :return:
            [[<composite_key>,[<index of entry>],...}
    
    get__flag_compare_check_different_types() -> 'bool'
    
    get__flag_compare_return_difference_of_values() -> 'bool'
    
    get_key_by_value(dict_: 'dict', value_: 'typing.Any')
        :param dict_:
        :param value_:
        :return: last key which is associated with value_ in dict_
    
    init_logger(debug_level: 'str' = 'TRACE', debug_output=<_io.TextIOWrapper name='<stderr>' mode='w' encoding='utf-8'>, debug_timeformat: 'str' = 'YYYY-MM-DD HH:mm:ss.SSS', debug_showobjectid=True, log_file_name: 'str' = None)
    
    load_file(file_name: 'str') -> 'list'
        # ********************************************************************
        # ********************************************************************
    
    load_serialized(file_name: 'str', equal_tag: 'str' = '=', separator_tag: 'str' = ';', comment_tags: 'typing.Union[tuple, list]' = ('#', '//'), remove_startswith: 'str' = '', remove_endswith: 'str' = '') -> 'n0list'
        # ********************************************************************
    
    n0debug(var_name: 'str', level: 'str' = 'DEBUG')
        Print value of the variable with name {var_name},
        depends of value in global variable {__debug_level}.
        
        :param var_name:
        :param level:
        :return:
    
    n0debug_calc(var_object, var_name: 'str' = '', level: 'str' = 'DEBUG', internal_call: 'int' = 0)
        Print  calculated value (for example returned by function),
        depends of value in global variable __debug_level.
        
        :param var_object:
        :param var_name:
        :param level:
        :return:
    
    n0debug_object(object_name: 'str', level: 'str' = 'DEBUG')
        # ******************************************************************************
    
    n0eval(_str: 'str') -> 'typing.Union[int, float, typing.Any]'
        # ********************************************************************
        # ********************************************************************
    
    n0isnumeric(value: 'str') -> 'bool'
        # ********************************************************************
        # ********************************************************************
    
    n0pretty(item: 'typing.Any', indent_: 'int' = 0, show_type: 'bool' = True, __indent_size: 'int' = 4)
        :param item:
        :param indent_:
        :return:
    
    n0print(text: 'str', level: 'str' = 'INFO', internal_call: 'int' = 0)
        if {level} <= {__debug_level} then print {text}{end}
        
        :param text:
        :param level:
        :param end:
        :param internal_call:
        :return: None
    
    notemptyitems(item)
        # ******************************************************************************
        # notemptyitems(item):
        #   Check item or recursively subitems of item.
        #   Return count of notempty item/subitems.
        # ******************************************************************************
    
    random_from(from_list: 'list') -> 'typing.Any'
        :param from_list:
        :return: from_list[rnd]
    
    rnd(till_not_included: 'int') -> 'int'
        :param till_not_included:
        :return: int [0..till_not_included)
    
    save_file(file_name: 'str', lines: 'typing.Any')
        # ********************************************************************
    
    set__flag_compare_check_different_types(value: 'bool')
        if __flag_compare_check_different_types == True, then
        validate type of attributes in .compare()/.direct_compare()
        and return result["difftypes"]
    
    set__flag_compare_return_difference_of_values(value: 'bool')
        if __flag_compare_return_difference_of_values == True, then
        if values of attributes are different and are int,float,
        return additional element in result["not_equal"] with difference
    
    split_name_index(node_name: 'str') -> 'typing.Tuple[str, typing.Union[str, typing.Tuple[str, str, typing.Union[str, bool]]]]'
        # ********************************************************************
        # ********************************************************************
    
    strip_ns lambda key
        # ******************************************************************************
    
    to_date(date_str: 'str') -> 'typing.Union[date, str]'
        # ********************************************************************
    
    transform_structure(in_structure, transform_key=<function <lambda> at 0x00000280E7C975E0>, transform_value=<function convert_to_native_format at 0x00000280E7C97670>)
        # ******************************************************************************
    
    xpath_match(xpath: 'str', xpath_list: 'typing.Union[str, list, tuple]') -> 'int'
        :param xpath:
            xpath: str
        :param xpath_list:
            xpath_list: str or list|tuple
        :return:
             0 not matched any of xpath_list
            >0 matched

DATA
    annotations = _Feature((3, 7, 0, 'beta', 1), (4, 0, 0, 'alpha', 0), 16...
    logger = <loguru.logger handlers=[(id=0, level=10, sink=<stderr>)]>

FILE
    c:\repo\n0struct\n0struct\__init__.py


